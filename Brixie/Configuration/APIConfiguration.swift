//
//  APIConfiguration.swift
//  Brixie
//
//  Created by GitHub Copilot on 18/09/2025.
//

import Foundation
import SwiftUI
import SwiftData
import RebrickableLegoAPIClient

/// API configuration manager for Rebrickable API integration
@Observable @MainActor
final class APIConfiguration {
    /// Singleton instance for shared configuration
    static let shared = APIConfiguration()
    
    /// User-configured API key stored in UserDefaults
    private var storedAPIKey: String {
        get {
            UserDefaults.standard.string(forKey: "rebrickableAPIKey") ?? ""
        }
        set {
            UserDefaults.standard.set(newValue, forKey: "rebrickableAPIKey")
        }
    }
    
    /// Whether the API key is currently valid and configured
    var isConfigured: Bool = false
    
    /// API client instance
    private var _apiClient: RebrickableLegoAPIClientAPIConfiguration?
    
    /// Current API client (recreated when API key changes)
    var apiClient: RebrickableLegoAPIClientAPIConfiguration? {
        if _apiClient == nil {
            configureAPIClient()
        }
        return _apiClient
    }
    
    /// Current API key from various sources
    var currentAPIKey: String? {
        // 1. Try user-configured key from settings
        if !storedAPIKey.isEmpty {
            return storedAPIKey
        }
        
        // 2. Try embedded key from build configuration
        if let embeddedKey = getEmbeddedAPIKey(), !embeddedKey.isEmpty {
            return embeddedKey
        }
        
        // 3. Try environment variable (for development/testing)
        if let envKey = ProcessInfo.processInfo.environment["REBRICKABLE_API_KEY"], !envKey.isEmpty {
            return envKey
        }
        
        return nil
    }
    
    // MARK: - Initialization
    
    init() {
        configureAPIClient()
        
        // Monitor API key changes
        NotificationCenter.default.addObserver(
            forName: UserDefaults.didChangeNotification,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            Task { @MainActor in
                self?.configureAPIClient()
            }
        }
    }
    
    // MARK: - Configuration
    
    /// Configure the API client with the current API key
    private func configureAPIClient() {
        guard let apiKey = currentAPIKey else {
            _apiClient = nil
            isConfigured = false
            return
        }
        
        _apiClient = RebrickableLegoAPIClientAPIConfiguration(apiKey: apiKey)
        isConfigured = true
        print("ðŸ”‘ API client configured successfully")
    }
    
    /// Update the user's API key
    func updateAPIKey(_ key: String) {
        storedAPIKey = key.trimmingCharacters(in: .whitespacesAndNewlines)
        configureAPIClient()
    }
    
    /// Clear the user's API key
    func clearAPIKey() {
        storedAPIKey = ""
        configureAPIClient()
    }
    
    /// Validate the current API key by making a test request
    func validateAPIKey() async -> Bool {
        guard let client = apiClient else {
            return false
        }
        
        do {
            // Make a simple API call to validate the key using LegoAPI
            _ = try await LegoAPI.legoColorsList(apiConfiguration: client)
            return true
        } catch {
            print("âŒ API key validation failed: \(error)")
            return false
        }
    }
    
    // MARK: - Embedded Configuration Support
    
    /// Get API key from embedded build configuration (generated by script)
    private func getEmbeddedAPIKey() -> String? {
        // Use GeneratedConfiguration from build-time generation
        if GeneratedConfiguration.hasEmbeddedAPIKey {
            return GeneratedConfiguration.rebrickableAPIKey
        }
        return nil
    }
}

// MARK: - Error Handling

extension APIConfiguration {
    /// Common API errors that can occur
    enum APIError: LocalizedError {
        case noAPIKey
        case invalidAPIKey
        case networkUnavailable
        case rateLimitExceeded
        case serverError(Int)
        case unknown(Error)
        
        var errorDescription: String? {
            switch self {
            case .noAPIKey:
                return NSLocalizedString("No API key configured. Please add your Rebrickable API key in Settings.", comment: "No API key error")
            case .invalidAPIKey:
                return NSLocalizedString("Invalid API key. Please check your Rebrickable API key in Settings.", comment: "Invalid API key error")
            case .networkUnavailable:
                return NSLocalizedString("Network unavailable. Please check your internet connection.", comment: "Network error")
            case .rateLimitExceeded:
                return NSLocalizedString("Rate limit exceeded. Please try again later.", comment: "Rate limit error")
            case .serverError(let code):
                return NSLocalizedString("Server error (\(code)). Please try again later.", comment: "Server error")
            case .unknown(let error):
                return error.localizedDescription
            }
        }
    }
    
    /// Convert common errors to APIError
    static func mapError(_ error: Error) -> APIError {
        // This will be expanded based on RebrickableAPI error types
        if let urlError = error as? URLError {
            switch urlError.code {
            case .notConnectedToInternet, .networkConnectionLost:
                return .networkUnavailable
            default:
                return .unknown(error)
            }
        }
        
        // HTTP status code mapping would go here based on RebrickableAPI
        return .unknown(error)
    }
}

// MARK: - Debug Support

#if DEBUG
extension APIConfiguration {
    /// Set a test API key for previews and testing
    func setTestAPIKey() {
        updateAPIKey("test_key_for_previews")
    }
    
    /// Reset to default state for testing
    func resetForTesting() {
        clearAPIKey()
        _apiClient = nil
        isConfigured = false
    }
}
#endif
